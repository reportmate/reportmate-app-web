import { NextResponse } from 'next/server'

// Force dynamic rendering and disable caching
export const dynamic = 'force-dynamic'
export const revalidate = 0

export async function GET() {
  try {
    const timestamp = new Date().toISOString()
    console.log(`[INVENTORY API] ${timestamp} - Fetching inventory data from Azure Functions API`)

    // Use server-side API base URL configuration
    const apiBaseUrl = process.env.API_BASE_URL
    
    if (!apiBaseUrl) {
      console.error(`[INVENTORY API] ${timestamp} - API_BASE_URL environment variable not configured`)
      return NextResponse.json({
        error: 'API configuration error',
        details: 'API_BASE_URL environment variable not configured'
      }, { status: 500 })
    }
    
    console.log(`[INVENTORY API] ${timestamp} - Using API base URL:`, apiBaseUrl)
    
    let response
    let useLocalFallback = false
    
    try {
      response = await fetch(`${apiBaseUrl}/api/inventory`, {
        cache: 'no-store',
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache',
          'X-API-PASSPHRASE': 's3cur3-p@ssphras3!'
        }
      })
      
      if (!response.ok) {
        console.error(`[INVENTORY API] ${timestamp} - Azure Functions API error:`, response.status, response.statusText)
        useLocalFallback = true
      }
    } catch (fetchError) {
      console.error(`[INVENTORY API] ${timestamp} - Failed to reach Azure Functions API:`, fetchError)
      useLocalFallback = true
    }
    
    // Fallback to local database query if Azure Functions API fails
    if (useLocalFallback) {
      console.log(`[INVENTORY API] ${timestamp} - Azure Functions /api/inventory not found - extracting from events`)
      
      try {
        // Try to get inventory data from events
        const eventsResponse = await fetch(`${apiBaseUrl}/api/events`, {
          cache: 'no-store',
          headers: {
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'X-API-PASSPHRASE': 's3cur3-p@ssphras3!'
          }
        })
        
        if (eventsResponse.ok) {
          const eventsData = await eventsResponse.json()
          
          if (eventsData.success && Array.isArray(eventsData.events)) {
            console.log(`[INVENTORY API] ${timestamp} - Extracting inventory data from ${eventsData.events.length} events`)
            
            // Find inventory module events
            const inventoryEvents = eventsData.events.filter((event: any) => 
              event.payload && 
              typeof event.payload === 'object' && 
              event.payload.module_id === 'inventory'
            )
            
            const inventoryData = inventoryEvents.map((event: any) => ({
              id: event.device,
              deviceId: event.device,
              deviceName: event.device,
              serialNumber: event.device,
              lastSeen: event.ts,
              collectedAt: event.payload.timestamp,
              dataSize: event.payload.data_size_kb,
              collectionType: event.payload.collection_type,
              eventId: event.id,
              message: event.message
            }))
            
            console.log(`[INVENTORY API] ${timestamp} - Found ${inventoryData.length} inventory events`)
            
            return NextResponse.json(inventoryData, {
              headers: {
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                'Pragma': 'no-cache', 
                'Expires': '0',
                'X-Fetched-At': timestamp,
                'X-Data-Source': 'azure-functions-events'
              }
            })
          }
        }
        
        console.error(`[INVENTORY API] ${timestamp} - Events fallback also failed`)
      } catch (eventsError) {
        console.error(`[INVENTORY API] ${timestamp} - Events fallback error:`, eventsError)
      }
      
      // If events fallback also fails, return 503
      return NextResponse.json(
        { error: 'Service temporarily unavailable - cloud infrastructure error' },
        { status: 503 }
      )
    }
      
      try {
        // Import database connection
        const { Pool } = require('pg')
        const pool = new Pool({
          connectionString: process.env.DATABASE_URL
        })

        const result = await pool.query(`
          SELECT 
            i.device_id,
            d.name as device_name,
            d.serial_number,
            d.last_seen,
            i.data,
            i.collected_at,
            i.created_at
          FROM inventory i
          JOIN devices d ON i.device_id = d.id
          ORDER BY i.updated_at DESC
          LIMIT 1000
        `)
        
        const inventoryData = result.rows.map((row: any) => {
          const data = row.data || {}
          
          return {
            id: row.device_id,
            deviceId: row.device_id,
            deviceName: data.deviceName || row.device_name || data.computerName || 'Unknown Device',
            serialNumber: row.serial_number,
            lastSeen: row.last_seen,
            collectedAt: row.collected_at,
            // Inventory-specific fields
            assetTag: data.assetTag || data.asset_tag || null,
            location: data.location || null,
            usage: data.usage || null,
            catalog: data.catalog || null,
            computerName: data.computerName || data.computer_name || null,
            domain: data.domain || null,
            organizationalUnit: data.organizationalUnit || data.organizational_unit || null,
            manufacturer: data.manufacturer || data.system?.manufacturer || null,
            model: data.model || data.system?.model || null,
            uuid: data.uuid || data.system?.uuid || null,
            // Raw data for debugging
            raw: data
          }
        })
        
        console.log(`[INVENTORY API] ${timestamp} - Successfully fetched ${inventoryData.length} inventory records from local database`)
        
        return NextResponse.json(inventoryData, {
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0',
            'X-Fetched-At': timestamp,
            'X-Data-Source': 'local-database'
          }
        })
        
      } catch (dbError) {
        console.error(`[INVENTORY API] ${timestamp} - Local database error:`, dbError)
        return NextResponse.json({
          error: 'Database error',
          details: 'Failed to fetch inventory data from both API and database'
        }, { status: 500 })
      }
    }
    
    // If we get here, Azure Functions API worked
    if (!response) {
      throw new Error('Response is undefined')
    }
    
    const data = await response.json()
    console.log(`[INVENTORY API] ${timestamp} - Successfully received data from Azure Functions API`)
    
    return NextResponse.json(data, {
      headers: {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
        'X-Fetched-At': timestamp,
        'X-Data-Source': 'azure-functions'
      }
    })
    
  } catch (error) {
    console.error('[INVENTORY API] Failed to fetch inventory data:', error)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred'
    
    return NextResponse.json({
      error: 'API request failed',
      details: errorMessage
    }, { status: 500 })
  }
}
